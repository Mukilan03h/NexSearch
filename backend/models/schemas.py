"""
Pydantic models for type safety and validation across the research assistant.
"""
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Literal
from datetime import datetime
from enum import Enum


class OutputFormat(str, Enum):
    """Supported output formats."""
    MARKDOWN = "markdown"
    PDF = "pdf"
    JSON = "json"


class Paper(BaseModel):
    """Academic paper model with normalized fields across all data sources."""
    id: str = Field(..., description="Unique identifier (e.g., arXiv ID)")
    title: str = Field(..., description="Paper title")
    authors: List[str] = Field(default_factory=list, description="List of author names")
    abstract: str = Field(..., description="Paper abstract")
    published_date: datetime = Field(..., description="Publication date")
    url: str = Field(..., description="Paper URL (abs page)")
    source: Literal["arxiv", "semantic_scholar", "pubmed", "openalex"] = Field(
        ..., description="Data source origin"
    )
    citations: Optional[int] = Field(None, description="Citation count if available")
    pdf_url: Optional[str] = Field(None, description="Direct PDF download URL")
    doi: Optional[str] = Field(None, description="DOI if available")
    relevance_score: Optional[float] = Field(None, ge=0.0, le=1.0, description="Computed relevance")

    @field_validator("authors", mode="before")
    @classmethod
    def ensure_authors_list(cls, v):
        """Ensure authors is always a list."""
        if isinstance(v, str):
            return [v]
        return v or []

    class Config:
        json_schema_extra = {
            "example": {
                "id": "2301.00001",
                "title": "Attention Is All You Need",
                "authors": ["Vaswani et al."],
                "abstract": "We propose a new architecture...",
                "published_date": "2023-01-01T00:00:00",
                "url": "https://arxiv.org/abs/2301.00001",
                "source": "arxiv",
            }
        }


class SearchPlan(BaseModel):
    """Search strategy generated by the Planner Agent."""
    keywords: List[str] = Field(..., min_length=1, description="Search keywords extracted from query")
    max_papers: int = Field(20, ge=1, le=100, description="Maximum papers to fetch")
    time_period: str = Field("last 2 years", description="Time period filter")
    fields: List[str] = Field(default_factory=list, description="Academic fields (e.g., AI, NLP)")
    sources: List[str] = Field(
        default_factory=lambda: ["arxiv"],
        description="Data sources to query"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "keywords": ["transformer", "attention mechanism", "NLP"],
                "max_papers": 15,
                "time_period": "2023-2025",
                "fields": ["Computer Science", "Artificial Intelligence"],
                "sources": ["arxiv", "semantic_scholar"],
            }
        }


class Theme(BaseModel):
    """Research theme/topic identified across analyzed papers."""
    name: str = Field(..., description="Theme name")
    description: str = Field(..., description="Brief theme description")
    paper_ids: List[str] = Field(default_factory=list, description="IDs of related papers")
    relevance_score: float = Field(0.0, ge=0.0, le=1.0, description="Relevance to original query")


class ResearchReport(BaseModel):
    """Final research report output."""
    query: str = Field(..., description="Original research query")
    generated_at: datetime = Field(default_factory=datetime.now)
    papers_analyzed: int = Field(..., ge=0, description="Number of papers analyzed")
    markdown_output: str = Field(..., description="Full report in markdown format")
    citations: List[str] = Field(default_factory=list, description="Formatted citations")
    themes: List[Theme] = Field(default_factory=list, description="Identified research themes")
    top_papers: List[Paper] = Field(default_factory=list, description="Most relevant papers used")
    report_id: Optional[str] = Field(None, description="Report ID in PostgreSQL")
    minio_url: Optional[str] = Field(None, description="MinIO storage URL for the report")

    def save_markdown(self, filepath: str) -> None:
        """Save report as markdown file."""
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(self.markdown_output)
